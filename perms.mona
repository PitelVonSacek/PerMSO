# Generated by perms.py
# version: {{ version }}
#
# Input matrix:
{% for row in C.M | reverse -%}
  #   {{row}}
{% endfor -%}
#
# Gridded: {{ gridded }}
# Avoid: {{ avoid | join(', ') }}
# Sum indecomposable: {{ sum_indecomposable }}
# Skew indecomposable: {{ skew_indecomposable }}
#
# Computed row signs: {{ C.row_signs | reverse | join(', ') }}
# Computed col signs: {{ C.col_signs | join(', ') }}

{%- macro parts(str) -%}
  {% for i in range(C.n) -%}
    {{str}}{{i}}
    {%- if not loop.last %}, {% endif -%}
  {% endfor -%}
{% endmacro %}
{%- set As = parts("A") %}
{%- set Xs = parts("X") %}
{%- set var_Xs = parts("var2 X") %}

m2l-str;

var2 {{As}};

pred partition({{var_Xs}}) = all1 x:
  ({% for i in range(C.n) -%} x in X{{i}} | {% endfor -%} false) &
  {% for i in range(C.n) -%}
    (x in X{{i}} => {% for j in range(C.n) if j != i -%}
      x notin X{{j}} & {##}
    {%- endfor -%} true) &
  {% endfor -%}
  true;

pred left_of(var1 x, var1 y) =
  {% for i in range(C.n) %}{% for j in range(C.n) -%}
    (x in A{{i}} & y in A{{j}} & {##}
      {%- if C.blocks[i].col < C.blocks[j].col -%}
        true
      {%- elif C.blocks[i].col > C.blocks[j].col -%}
        false
      {%- elif C.col_signs[C.blocks[i].col] == 1 -%}
        x < y
      {%- else -%}
        x > y
      {%- endif -%}
    ) |
  {% endfor %}{% endfor -%}
  false;

pred below_of(var1 x, var1 y) =
  {% for i in range(C.n) %}{% for j in range(C.n) -%}
    (x in A{{i}} & y in A{{j}} & {##}
      {%- if C.blocks[i].row < C.blocks[j].row -%}
        true
      {%- elif C.blocks[i].row > C.blocks[j].row -%}
        false
      {%- elif C.row_signs[C.blocks[i].row] == 1 -%}
        x < y
      {%- else -%}
        x > y
      {%- endif -%}
    ) |
  {% endfor %}{% endfor -%}
  false;

pred Mon'({{var_Xs}}) =
  partition({{Xs}}) &
  # Check that positions are respected inside blocks
  {% for i in range(C.n) -%}
    (all1 x, y: (x in X{{i}} & y in X{{i}} & left_of(x, y)) => {##}
      {%- if C.blocks[i].sign == 1 -%}
        below_of(x, y)
      {%- else -%}
        below_of(y, x)
      {%- endif -%}
    ) &
  {% endfor -%}
  # Check that positions are respected between blocks
  {% for i in range(C.n) %}{% for j in range(C.n) -%}
    (all1 x, y: (x in X{{i}} & y in X{{j}}) => {##}
      {%- if C.blocks[i].row < C.blocks[j].row -%}
        below_of(x, y) & {##}
      {%- endif -%}
      {%- if C.blocks[i].col < C.blocks[j].col -%}
        left_of(x, y) & {##}
      {%- endif -%}
    true) &
  {% endfor %}{% endfor -%}
  true;

pred bigger_than_A({{var_Xs}}) = ex1 x:
  let2 B0 = empty in
  {% for i in range(1, C.n) -%}
    let2 B{{i}} = B{{i-1}} union A{{i-1}} in
  {% endfor -%}
  # x is earlier in As than in Xs
  {% for i in range(C.n) -%}
    (x in X{{i}} => x in B{{i}}) &
  {% endfor -%}
  # and all elements left of x are the same in As and Xs
  (all1 y: left_of(y, x) => (
    {% for i in range(C.n) -%}
      (y in A{{i}} <=> y in X{{i}}) &
    {% endfor -%}
    true
  ));

pred different({{var_Xs}}) =
  {% for i in range(C.n) -%}
    X{{i}} ~= A{{i}} |
  {% endfor -%}
  false;

pred minimal_gridding() = all2 {{Xs}}:
  Mon'({{Xs}}) & different({{Xs}})
  => bigger_than_A({{Xs}});

pred I(var1 x, var1 y) =
  {% for i in range(C.n) -%}{%- for j in range(C.n) -%}
    {% if C.blocks[i].row != C.blocks[j].row and
          C.blocks[i].col != C.blocks[j].col -%}
      (x in A{{i}} & y in A{{j}}) |
  {##}
    {%- endif %}
  {%- endfor %}{% endfor -%}
  false;

pred cmp_lex(var1 x, var1 y) =
  {% for i in range(1, C.n) -%}{%- for j in range(i) -%}
    (x in A{{j}} & y in A{{i}}) |
  {% endfor %}{% endfor -%}
  false;

pred trace_min() = all1 a, b:
  a < b & (all1 x: x >= a & x < b => I(x, b)) =>
  cmp_lex(a, b);

{#- Match specified permutation #}
{% macro match(pat) %}{% with N = pat | length -%}
  (
    # Match permutation {{pat}}
    ex1 x{{ range(N) | join(", x") }}:
    # x_i are left to right
    {% for i in range(1, N) -%}
      left_of(x{{i - 1}}, x{{i}}) & {##}
    {%- endfor %}
    # fix correct vertical order
    {% for x in pat | sort %}{% if not loop.first -%}
      below_of(x{{ pat.index(loop.previtem) }}, x{{ pat.index(x) }}) & {##}
    {%- endif %}{% endfor %}
    true
  )
{%- endwith %}{% endmacro %}

pred avoid() =
  {% for pat in avoid -%}
    ~{{ match(pat) }} &
  {% endfor -%}
  true;

pred sum_decomposable() =
  # x is left-most element of upper right part
  # y is top-most element of lower left part
  ex1 x, y: all1 z: left_of(z, x) <=> ~below_of(y, z);

pred skew_decomposable() =
  # x is left-most element of lower right part
  # y is bottom-most element of upper left part
  ex1 x, y: all1 z: left_of(z, x) <=> ~below_of(z, y);


partition({{As}}) &
trace_min() &
avoid() &
{% if not gridded -%}
  minimal_gridding() &
{% endif -%}
{% if sum_indecomposable -%}
  ~sum_decomposable() &
{% endif -%}
{% if skew_indecomposable -%}
  ~skew_decomposable() &
{% endif -%}
true;

