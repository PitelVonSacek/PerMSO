# Generated by perms.py
# version: {{ version }}
#
# Input matrix:
{% for row in C.M | reverse -%}
  #   {{row}}
{% endfor -%}
#
# Computed row signs: {{ C.row_signs | reverse | join(', ') }}
# Computed col signs: {{ C.col_signs | join(', ') }}

{%- macro parts(str) -%}
  {% for i in range(C.n) -%}
    {{str}}{{i}}
    {%- if not loop.last %}, {% endif -%}
  {% endfor -%}
{% endmacro %}
{%- set As = parts("A") %}
{%- set Xs = parts("X") %}
{%- set var_Xs = parts("var2 X") %}

m2l-str;

var2 {{As}};

pred partition({{var_Xs}}) = all1 x:
  ({% for i in range(C.n) -%} x in X{{i}} | {% endfor -%} false) &
  {% for i in range(C.n) -%}
    (x in X{{i}} => {% for j in range(C.n) | reject("eq", i) -%}
      x notin X{{j}} & {##}
    {%- endfor -%} true) &
  {% endfor -%}
  true;

pred left_of(var1 x, var1 y) =
  {% for i in range(C.n) %}{% for j in range(C.n) -%}
    (x in A{{i}} & y in A{{j}} & {##}
      {%- if C.blocks[i].col < C.blocks[j].col -%}
        true
      {%- elif C.blocks[i].col > C.blocks[j].col -%}
        false
      {%- elif C.col_signs[C.blocks[i].col] == 1 -%}
        x < y
      {%- else -%}
        x > y
      {%- endif -%}
    ) |
  {% endfor %}{% endfor -%}
  false;

pred below_of(var1 x, var1 y) =
  {% for i in range(C.n) %}{% for j in range(C.n) -%}
    (x in A{{i}} & y in A{{j}} & {##}
      {%- if C.blocks[i].row < C.blocks[j].row -%}
        true
      {%- elif C.blocks[i].row > C.blocks[j].row -%}
        false
      {%- elif C.row_signs[C.blocks[i].row] == 1 -%}
        x < y
      {%- else -%}
        x > y
      {%- endif -%}
    ) |
  {% endfor %}{% endfor -%}
  false;

pred Mon'({{var_Xs}}) =
  partition({{Xs}}) &
  # Check that positions are respected inside blocks
  {% for i in range(C.n) -%}
    (all1 x, y: (x in X{{i}} & y in X{{i}} & left_of(x, y)) => {##}
      {%- if C.blocks[i].sign == 1 -%}
        below_of(x, y)
      {%- else -%}
        below_of(y, x)
      {%- endif -%}
    ) &
  {% endfor -%}
  # Check that positions are respected between blocks
  {% for i in range(C.n) %}{% for j in range(C.n) -%}
    (all1 x, y: (x in X{{i}} & y in X{{j}}) => {##}
      {%- if C.blocks[i].row < C.blocks[j].row -%}
        below_of(x, y) & {##}
      {%- endif -%}
      {%- if C.blocks[i].col < C.blocks[j].col -%}
        left_of(x, y) & {##}
      {%- endif -%}
    true) &
  {% endfor %}{% endfor -%}
  true;

pred bigger_than_A({{var_Xs}}) = ex1 x:
  let2 B0 = empty in
  {% for i in range(1, C.n) -%}
    let2 B{{i}} = B{{i-1}} union A{{i-1}} in
  {% endfor -%}
  # x is earlier in As than in Xs
  {% for i in range(C.n) -%}
    (x in X{{i}} => x in B{{i}}) &
  {% endfor -%}
  # and all elements left of x are the same in As and Xs
  (all1 y: left_of(y, x) => (
    {% for i in range(C.n) -%}
      (y in A{{i}} <=> y in X{{i}}) &
    {% endfor -%}
    true
  ));

pred different({{var_Xs}}) =
  {% for i in range(C.n) -%}
    X{{i}} ~= A{{i}} |
  {% endfor -%}
  false;

pred minimal_gridding() = all2 {{Xs}}:
  Mon'({{Xs}}) & different({{Xs}})
  => bigger_than_A({{Xs}});

pred trace_min() = all1 x: x > 0 =>
  {% for i in range(C.n) -%}
    (x - 1 in A{{i}} => (
      {%- for j in range(i) -%}
        {% if C.blocks[i].row != C.blocks[j].row and
              C.blocks[i].col != C.blocks[j].col -%}
          x notin A{{j}} & {##}
        {%- endif %}
      {%- endfor -%}
    true)) &
  {% endfor -%}
  true;

partition({{As}}) & minimal_gridding() & trace_min();
